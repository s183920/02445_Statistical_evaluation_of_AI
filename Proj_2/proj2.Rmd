---
title: "Project 2"
author: "Lukas Leindals"
date: "15/1/2020"
output:
  word_document:
    toc: yes
  html_document:
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# set seed
set.seed(-2000)

# packages
library(ggplot2)
library(magrittr)
```



# Data

```{r echo=FALSE}
data_fos <- get(load("fosfor_data.Rdata")) %>% 
  data.frame() %>% 
  dplyr::mutate(location = as.factor(location))
data_fos

```

## Summaries

```{r}
cat("Structure")
str(data_fos)
cat("Summary")
summary(data_fos)
cat("Data")
data_fos

# nas <- which(is.na(data_fos$yield)) 
# data_fos[unique(c(nas, nas+1, nas-1)), ]

#xtable::xtable(summary(data_fos, maxsum = 9)) #converts to latex

      
```

## Handle NA's

Uses KNN imputation and looks at the k nearest neighbors, the missing value is then replaced with the average of the values for the nearest neighbors

```{r}
data_fos <- DMwR::knnImputation(data_fos,k=2, meth = "Median")
```

## grouped data set

groups the data, so that there is only one yield for each combination of location, DGT and olsenP, which is the mean. THis is done as these three factors are strongly dependent of each other.

```{r}
data_grouped <- data_fos %>% dplyr::group_by(location, DGT, olsenP) %>% dplyr::summarise_each(mean)
data_grouped

ggplot(tidyr::gather(data_grouped, "key", "value", -c(location, yield)), aes(value, yield, col = location)) +
  geom_point() +
  facet_wrap("key", scales = "free")
```


## Plots

Comparison plot

```{r}
GGally::ggpairs(data_fos, columns = c("DGT", "olsenP", "yield"), title = "Data summary")
ggsave("data_plot.jpg")
```

Boxplots

```{r}
#par(mfrow = c(3,1))
boxplot(yield ~location, data = data_fos)
boxplot(DGT ~ location, data = data_fos)
boxplot(olsenP ~ location, data = data_fos)

data_fos %>% 
  tidyr::gather("key", "value", -location) %>%
  dplyr::filter(key == "yield") %>% 
  dplyr::rename(yield = value) %>% 
  ggplot(aes(x = location, y = yield)) + 
    geom_boxplot(fill = 'green') 
ggsave("boxplot_yield_location.jpg")


```

Scatter plots

```{r}
par(mfrow = c(1,2))
plot(data = data_fos , yield ~ olsenP)
plot(data = data_fos , yield ~ DGT)
```

# OlsenP vs. DGT

## ANOVA

```{r}
lm1 <- lm(data = data_fos, formula = yield ~ DGT)
anova(lm1)
summary(lm1)


lm2 <- lm(data = data_fos, formula = yield ~ olsenP)
anova(lm2)
summary(lm2)

lm3 <- lm(data = data_fos, formula = yield ~ location)
anova(lm3)
summary(lm3)


phos.model.DGT <- nls(yield ~ alfa * DGT/(beta + DGT) , data = data_fos,
start = list(alfa = 90 , beta = 1))

phos.model.olsenP <- nls(yield ~ alfa * olsenP/(beta + olsenP) , data = data_fos,
start = list(alfa = 90 , beta = 1))

phos.model.DGT_mean <- nls(yield ~ alfa * DGT/(beta + DGT) , data = data_grouped,
start = list(alfa = 90 , beta = 1))

phos.model.olsenP_mean <- nls(yield ~ alfa * olsenP/(beta + olsenP) , data = data_grouped,
start = list(alfa = 90 , beta = 1))

phos.model.DGT_lm <- lm(yield ~ DGT , data = data_fos)

phos.model.olsenP_lm <- lm(yield ~ olsenP, data = data_fos)

summary(phos.model.DGT)
summary(phos.model.olsenP)


# lm_august <- nls(yield ~ a * olsenP/(b+olsenP), data = data_fos, start = list(b = max(data_fos$yield)/2, a = max(data_fos$yield)))
# anova(lm_august)
# summary(lm_august)
# coef(lm_august)
# lm_august
# phos.model.olsenP

```

### Plots of model coefficients

```{r}
par(mfrow=(c(3,2)))
alfa1 <- coef(phos.model.DGT)[1]
beta1 <- coef(phos.model.DGT)[2]
alfa2 <- coef(phos.model.olsenP)[1]
beta2 <- coef(phos.model.olsenP)[2]
alfa3 <- coef(phos.model.DGT_mean)[1]
beta3 <- coef(phos.model.DGT_mean)[2]
alfa4 <- coef(phos.model.olsenP_mean)[1]
beta4 <- coef(phos.model.olsenP_mean)[2]


plot(data = data_fos , yield ~ DGT)
lines(x<-c(1:200),(alfa1 * x )/(beta1 + x),col='red')
plot(data = data_fos , yield ~ olsenP)
lines(x<-c(1:200),(alfa2 * x )/(beta2 + x),col='red')
plot(data = data_grouped , yield ~ DGT)
lines(x<-c(1:200),(alfa3 * x )/(beta3 + x),col='red')
plot(data = data_grouped , yield ~ olsenP)
lines(x<-c(1:200),(alfa4 * x )/(beta4 + x),col='red')


plot(data = data_fos , yield ~ DGT)
abline(coef(phos.model.DGT_lm))
plot(data = data_fos , yield ~ olsenP)
abline(coef(phos.model.olsenP_lm))
```

### Parametric bootstrapping - Konfidensintervaller for bestemmelse af parametrene
```{r}
l <- summary(phos.model.DGT)
summary(phos.model.DGT)


summary(phos.model.olsenP)
```



```{r}

```

## Predicting yield

Test errorrate med leave one out cross validation

```{r}
data_CV <- data_grouped

N <- nrow(data_CV)
s <- sample(N)
K_fold <- N


accuracy <- c()
random_index <- split(sample(c(1:N),N), c(1:K_fold))
loss <- c()
for (i in c(1:K_fold)){
  f <- c(1:K_fold)[-i]
  train_index <- Reduce(c,random_index[f])
  test_index <- Reduce(c,random_index[i])

  train_set <- data_CV[train_index,]
  test_set <- data_CV[test_index,]
  model_cv_DGT <- phos.model.DGT_perm <- nls(yield ~ alfa * DGT/(beta + DGT) , data = train_set,
                        start = list(alfa = 90 , beta = 1))
  
  model_cv_olsenP <- phos.model.DGT_perm <- nls(yield ~ alfa * olsenP/(beta + olsenP) , data = train_set,
                        start = list(alfa = 90 , beta = 1))
  
  lm_model_DGT <- lm(data = data_fos, formula = yield ~ DGT)
  lm_model_olsenP <- lm(data = data_fos, formula = yield ~ olsenP)
  
  
  pred_DGT <- predict(model_cv_DGT, test_set)
  pred_olsenP <- predict(model_cv_olsenP, test_set)
  
  pred_lmDGT <- predict(lm_model_DGT, test_set)
  pred_lmolsenP <- predict(lm_model_olsenP, test_set)
  
  error_DGT <- (test_set$yield - pred_DGT)^2
  error_olsenP <- (test_set$yield - pred_olsenP)^2
  
  error_lmDGT <- (test_set$yield - pred_lmDGT)^2 
  error_lmolsenP <- (test_set$yield - pred_lmolsenP)^2

  loss <- rbind(loss,c(error_DGT, error_olsenP, error_lmDGT, error_lmolsenP))
  
}
loss <- as.data.frame(loss)
names(loss) <- c("nlDGT", "nlolsenP", "lmDGT", "lmolsenP")
apply(loss,2,mean)

Z <- loss$nlDGT - loss$nlolsenP
mean(Z)
loss$nlDGT
t.test(Z)
t.test(loss$nlDGT, loss$nlolsenP, paired =T)
qqnorm(Z)
qqline(Z)

loss$nlDGT
loss$nlolsenP
t.test(loss$nlDGT, loss$nlolsenP, paired =T)
```

### Bootstrap - loss

Difference in performance with Michaelis Menten fitted to DGT vs olsenP
Non parametric bootstrapping. Sampler fra forskel i loss af de to modeller. Udregner mean af disse forskelle og bestemmer konfidens intervaller.

```{r}
z_bootstrap <- apply( replicate(10000, sample(Z, replace = T)), 2, mean)
hist(z_bootstrap)
abline(v = mean(Z))
alfa <- 0.05
quantile(z_bootstrap, c(alfa/2,1-alfa/2))
```

### Rank Sum Test 

Difference in performance with Michaelis Menten fitted to DGT vs olsenP
Concatenates loss af DGT og olsenP. Bestemmers størrelseordenen af denne vektor og finder rank sum for DGT.
Derefter laves permutationer af vektor med 1-72 og rank sum af de 36 første bestemmes og sammenlignes med rank sum for DGT

```{r}
Z_RST <- order(c(loss$nlDGT, loss$nlolsenP))
DGT_RS <- sum(Z_RST[1:length(Z_RST)/2])
RST <- c()
for (i in 1:1000){
  RST_sample <- sample(length(Z_RST))
  RST <- c(RST,sum(RST_sample[1:length(Z_RST)/2]))
}
p_val <- 2*mean(DGT_RS>RST)

hist(RST)
abline(v = DGT_RS)
p_val

```

# Influence of phosphorous

## Permutation test

```{r}
data_permutation <- data_fos
n <- 10000
results_DGT <- c()
results_olsenP <- c()
results_DGT_LM <- c()
results_olsenP_LM <- c()

for (i in 1:n){
  permutation <- sample(nrow(data_permutation))
  
  phos.model.DGT_perm <- nls(yield[permutation] ~ alfa * DGT/(beta + DGT) , data = data_permutation,
                        start = list(alfa = 90 , beta = 1), nls.control(warnOnly = T))

  phos.model.olsenP_perm <- nls(yield[permutation] ~ alfa * olsenP/(beta + olsenP) , data = data_permutation,
                            start = list(alfa = 90 , beta = 1), nls.control(warnOnly = T))
  
  
  phos.model.DGT_lm_perm <- lm(yield[permutation] ~ DGT, data = data_permutation)
  phos.model.olsenP_lm_perm <- lm(yield[permutation] ~ olsenP, data = data_permutation)
  
  results_DGT <- rbind(results_DGT, coef(phos.model.DGT_perm))
  results_olsenP <- rbind(results_olsenP, coef(phos.model.olsenP_perm))
  results_DGT_LM <- rbind(results_DGT_LM, coef(phos.model.DGT_lm_perm))
  results_olsenP_LM <- rbind(results_olsenP_LM, coef(phos.model.olsenP_lm_perm))
}

par(mfrow = c(1,2))
hist(results_DGT[,1], xlim = c(50,100))
abline(v = alfa1)

hist(results_DGT[,2])
abline(v = beta1)

hist(results_DGT_LM[,2], xlim = c(-0.5,0.5))
abline(v = coef(phos.model.DGT_lm)[2])
coef(phos.model.DGT_lm)[2]

plot(data_permutation$yield[permutation] ~ data_permutation$DGT)
```


```{r}
data_fos
model <- lm(data = data_fos, formula = yield ~ location)
summary(model)
anova(model)
par(mfrow = c(1,2))
boxplot(data_fos$yield ~ data_fos$location)
plot(data_fos$yield ~ data_fos$location, ylim = c(0,100))
points(data_fos$yield ~ data_fos$location, col = 2)
coef(model)

```





















### LEAVE 4 OUT!!!!






```{r}
data_CV <- data_fos
level <- levels(data_CV$location)
N <- length(level)

s <- sample(N)
K_fold <- N


accuracy <- c()
random_index <- split(sample(c(1:N),N), c(1:K_fold))
loss <- c()

for (i in c(1:K_fold)){


  train_set <- subset(data_CV, location != level[i])
  test_set <- subset(data_CV, location == level[i])
  model_cv_DGT <- phos.model.DGT_perm <- nls(yield ~ alfa * DGT/(beta + DGT) , data = train_set,
                        start = list(alfa = 90 , beta = 1))
  
  model_cv_olsenP <- phos.model.DGT_perm <- nls(yield ~ alfa * olsenP/(beta + olsenP) , data = train_set,
                        start = list(alfa = 90 , beta = 1))
  
  lm_model_DGT <- lm(data = data_fos, formula = yield ~ DGT)
  lm_model_olsenP <- lm(data = data_fos, formula = yield ~ olsenP)
  
  
  pred_DGT <- predict(model_cv_DGT, test_set)
  pred_olsenP <- predict(model_cv_olsenP, test_set)

  pred_lmDGT <- predict(lm_model_DGT, test_set)
  pred_lmolsenP <- predict(lm_model_olsenP, test_set)

  
  error_DGT <- (test_set$yield - pred_DGT)^2
  error_olsenP <- (test_set$yield - pred_olsenP)^2
  
  error_lmDGT <- (test_set$yield - pred_lmDGT)^2 
  error_lmolsenP <- (test_set$yield - pred_lmolsenP)^2

  loss <- rbind(loss,cbind(error_DGT, error_olsenP, error_lmDGT, error_lmolsenP))
  loss
}
loss <- as.data.frame(loss)
names(loss) <- c("nlDGT", "nlolsenP", "lmDGT", "lmolsenP")
apply(loss,2,mean)

t.test(loss$nlDGT, loss$nlolsenP, paired =T )
Z <- loss$nlDGT - loss$nlolsenP
qqnorm(Z)
qqline(Z)

loss
qqnorm(loss$nlolsenP)
qqline(loss$nlolsenP)
t.test(Z)
214

mean(loss$nlDGT) + sd(loss$nlDGT)/sqrt(36) * qt(0.975, 35)
```

### Bootstrapping for MSE confidence intervals
```{r}
a <- 0.05
bootstap_DGT <- replicate(10000,mean(sample(loss$nlDGT, replace = T)))
bootstap_olsenP <- replicate(10000,mean(sample(loss$nlolsenP, replace = T)))
bootstrap_Z <- replicate(10000,mean(sample(Z, replace = T)))
quantile(bootstap_olsenP, c(a/2, 1-a/2))
quantile(bootstap_DGT, c(a/2, 1-a/2))
quantile(bootstrap_Z, c(a/2, 1-a/2))
```


### Permutation - med hensyn til grupper måske ... 

```{r}
set.seed(1997)
n <- 10000
data_permutation <- data_fos

permutation_list <- split(data_permutation$yield, data_permutation$location)

results <- c()

for (i in 1:n){
  permutation <- sample(9)
  data_permutation$yield = unlist(permutation_list[permutation])
  phos.model.DGT_perm <- nls(yield ~ alfa * DGT/(beta + DGT) , data = data_permutation,
                        start = list(alfa = 90 , beta = 1), nls.control(warnOnly = T, minFactor = 0))
  
  phos.model.olsenP_perm <- nls(yield ~ alfa * olsenP/(beta + olsenP) , data = data_permutation,
                            start = list(alfa = 90 , beta = 1), nls.control(warnOnly = T))
  
  

  
  results <- rbind(results, c(coef(phos.model.DGT_perm), coef(phos.model.olsenP_perm)))

}
results <- as.data.frame(results)
names(results) <- c("a-DGT", "b-DGT", "a-olsenP", "b-olsenP")

par(mfrow = c(2,2))
hist(results$`a-DGT`)
abline(v = c(quantile(results$`a-DGT`, c(a/2,1-a)),alfa1), col = c(1,2,3))
(alfa1-mean(results$`a-DGT`))/sd(results$`a-DGT`)

hist(results$`a-olsenP`)
abline(v = alfa2)

hist(results$`b-DGT`)
abline(v = beta1)

hist(results$`b-olsenP`)
abline(v = beta2)

mean(beta1 < results$`b-DGT`)
mean(beta2 < results$`b-olsenP`)
alfa1
quantile(results$`a-DGT`, c(a/2,1-a/2))
alfa1
```

