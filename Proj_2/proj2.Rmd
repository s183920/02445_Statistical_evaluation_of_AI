---
title: "Project 2"
author: "Lukas Leindals"
date: "15/1/2020"
output: 
  html_document:
    toc: true
    toc_float: true
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# packages
library(ggplot2)
```



# Data

```{r echo=FALSE}
data_fos <- get(load("fosfor_data.Rdata")) %>% 
  data.frame() %>% 
  dplyr::mutate(location = as.factor(location))
data_fos

```

## Summaries

```{r}
cat("Structure")
str(data_fos)
cat("Summary")
summary(data_fos)
cat("Data")
data_fos

# nas <- which(is.na(data_fos$yield)) 
# data_fos[unique(c(nas, nas+1, nas-1)), ]
      
```

## Handle NA's

Uses KNN imputation and looks at the k nearest neighbors, the missing value is then replaced with the average of the values for the nearest neighbors

```{r}
data_fos <- DMwR::knnImputation(data_fos,k=2, meth = "Median")
```

## grouped data set

groups the data, so that there is only one yield for each combination of location, DGT and olsenP, which is the mean. THis is done as these three factors are strongly dependent of each other.

```{r}
data_grouped <- data_fos %>% dplyr::group_by(location, DGT, olsenP) %>% dplyr::summarise_each(mean)
data_grouped

ggplot(tidyr::gather(data_grouped, "key", "value", -c(location, yield)), aes(value, yield, col = location)) +
  geom_point() +
  facet_wrap("key", scales = "free")
```


## Plots

```{r}
GGally::ggpairs(data_fos, columns = c("DGT", "olsenP", "yield"))


#par(mfrow = c(3,1))
boxplot(yield ~location, data = data_fos)
boxplot(DGT ~ location, data = data_fos)
boxplot(olsenP ~ location, data = data_fos)

#data_fos %>% tidyr::gather("key", "value", -location) %>% ggplot(aes(x = location, y = value, fill = key)) + geom_boxplot() + facet_wrap("key")
par(mfrow = c(1,2))
plot(data = data_fos , yield ~ olsenP)
plot(data = data_fos , yield ~ DGT)
```


# Models

## ANOVA

```{r}
lm1 <- lm(data = data_fos, formula = yield ~ DGT)
anova(lm1)
summary(lm1)


lm2 <- lm(data = data_fos, formula = yield ~ olsenP)
anova(lm2)
summary(lm2)

lm3 <- lm(data = data_fos, formula = yield ~ location)
anova(lm3)
summary(lm3)


phos.model.DGT <- nls(yield ~ alfa * DGT/(beta + DGT) , data = data_fos,
start = list(alfa = 90 , beta = 1))

phos.model.olsenP <- nls(yield ~ alfa * olsenP/(beta + olsenP) , data = data_fos,
start = list(alfa = 90 , beta = 1))

plot(phos.model)

summary(phos.model.DGT)
summary(phos.model.olsenP)

plot(phos.model$m$gradient())

length(phos.model$m$gradient())

par(mfrow=(c(1,2)))
alfa1 <- coef(phos.model.DGT)[1]
beta1 <- coef(phos.model.DGT)[2]
alfa2 <- coef(phos.model.olsenP)[1]
beta2 <- coef(phos.model.olsenP)[2]
plot(data = data_fos , yield ~ DGT)
lines(x<-c(1:200),(alfa1 * x )/(beta1 + x),col='red')
plot(data = data_fos , yield ~ olsenP)
lines(x<-c(1:200),(alfa2 * x )/(beta2 + x),col='red')
```

```{r}
lm3 <- lm(data = data_fos, formula = DGT ~ location)
summary(lm3)
cor(data_fos$location, data_fos$DGT)
```
# Permutation test

```{r}
n <- 500
results_DGT <- c()
results_olsenP <- c()
for (i in 1:n){
  permutation <- sample(nrow(data_fos))
  
  phos.model.DGT_perm <- nls(yield[permutation] ~ alfa * DGT/(beta + DGT) , data = data_fos,
                        start = list(alfa = 90 , beta = 1))

  phos.model.olsenP_perm <- nls(yield[permutation] ~ alfa * olsenP/(beta + olsenP) , data = data_fos,
                            start = list(alfa = 90 , beta = 1))
  
  results_DGT <- rbind(results_DGT, coef(phos.model.DGT_perm))
  results_olsenP <- rbind(results_olsenP, coef(phos.model.olsenP_perm))
}
sum(beta1 < results_DGT[,2])
mean(results_DGT[,2])
alfa1
beta1
```

# Predictions
```{r}
pred <- predict(phos.model.DGT, data_fos$DGT)
plot(pred ~data_fos$DGT)
```




