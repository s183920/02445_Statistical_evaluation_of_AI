---
title: "Project 2"
author: "Lukas Leindals"
date: "15/1/2020"
output:
  word_document:
    toc: yes
  html_document:
    toc: yes
    toc_float: yes
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# set seed
set.seed(-2000)

# packages
library(ggplot2)
library(magrittr)
```



# Data

```{r echo=FALSE}
data_fos <- get(load("fosfor_data.Rdata")) %>% 
  data.frame() %>% 
  dplyr::mutate(location = as.factor(location))
data_fos

```

## Summaries

```{r}
cat("Structure")
str(data_fos)
cat("Summary")
summary(data_fos)
cat("Data")
data_fos

# nas <- which(is.na(data_fos$yield)) 
# data_fos[unique(c(nas, nas+1, nas-1)), ]

#xtable::xtable(summary(data_fos, maxsum = 9)) #converts to latex

      
```

## Handle NA's

Uses KNN imputation and looks at the k nearest neighbors, the missing value is then replaced with the average of the values for the nearest neighbors

```{r}
data_fos <- DMwR::knnImputation(data_fos,k=2, meth = "Median")
```

## grouped data set

groups the data, so that there is only one yield for each combination of location, DGT and olsenP, which is the mean. THis is done as these three factors are strongly dependent of each other.

```{r}
data_grouped <- data_fos %>% dplyr::group_by(location, DGT, olsenP) %>% dplyr::summarise_each(mean)
data_grouped

ggplot(tidyr::gather(data_grouped, "key", "value", -c(location, yield)), aes(value, yield, col = location)) +
  geom_point() +
  facet_wrap("key", scales = "free")
```


## Plots

Comparison plot

```{r}
GGally::ggpairs(data_fos, columns = c("DGT", "olsenP", "yield"), title = "Data summary")
ggsave("data_plot.jpg")
```

Boxplots

```{r}
#par(mfrow = c(3,1))
boxplot(yield ~location, data = data_fos)
boxplot(DGT ~ location, data = data_fos)
boxplot(olsenP ~ location, data = data_fos)

data_fos %>% 
  tidyr::gather("key", "value", -location) %>%
  dplyr::filter(key == "yield") %>% 
  dplyr::rename(yield = value) %>% 
  ggplot(aes(x = location, y = yield)) + 
    geom_boxplot(fill = 'green') 
ggsave("boxplot_yield_location.jpg")


```

Scatter plots

```{r}
par(mfrow = c(1,2))
plot(data = data_fos , yield ~ olsenP)
plot(data = data_fos , yield ~ DGT)
```

# OlsenP vs. DGT

## ANOVA

```{r}
lm1 <- lm(data = data_fos, formula = yield ~ DGT)
anova(lm1)
summary(lm1)


lm2 <- lm(data = data_fos, formula = yield ~ olsenP)
anova(lm2)
summary(lm2)

lm3 <- lm(data = data_fos, formula = yield ~ location)
anova(lm3)
summary(lm3)


phos.model.DGT <- nls(yield ~ alfa * DGT/(beta + DGT) , data = data_fos,
start = list(alfa = 90 , beta = 1))

phos.model.olsenP <- nls(yield ~ alfa * olsenP/(beta + olsenP) , data = data_fos,
start = list(alfa = 90 , beta = 1))

phos.model.DGT_mean <- nls(yield ~ alfa * DGT/(beta + DGT) , data = data_grouped,
start = list(alfa = 90 , beta = 1))

phos.model.olsenP_mean <- nls(yield ~ alfa * olsenP/(beta + olsenP) , data = data_grouped,
start = list(alfa = 90 , beta = 1))

phos.model.DGT_lm <- lm(yield ~ DGT , data = data_fos)

phos.model.olsenP_lm <- lm(yield ~ olsenP, data = data_fos)

summary(phos.model.DGT)
summary(phos.model.olsenP)


# lm_august <- nls(yield ~ a * olsenP/(b+olsenP), data = data_fos, start = list(b = max(data_fos$yield)/2, a = max(data_fos$yield)))
# anova(lm_august)
# summary(lm_august)
# coef(lm_august)
# lm_august
# phos.model.olsenP

```

### Plots of model coefficients

```{r}
par(mfrow=(c(3,2)))
alfa_DGT <- coef(phos.model.DGT)[1]
beta_DGT <- coef(phos.model.DGT)[2]
alfa_olsenP <- coef(phos.model.olsenP)[1]
beta_olsenP <- coef(phos.model.olsenP)[2]
alfa3 <- coef(phos.model.DGT_mean)[1]
beta3 <- coef(phos.model.DGT_mean)[2]
alfa4 <- coef(phos.model.olsenP_mean)[1]
beta4 <- coef(phos.model.olsenP_mean)[2]


plot(data = data_fos , yield ~ DGT)
lines(x<-c(1:200),(alfa1 * x )/(beta1 + x),col='red')
plot(data = data_fos , yield ~ olsenP)
lines(x<-c(1:200),(alfa2 * x )/(beta2 + x),col='red')
plot(data = data_grouped , yield ~ DGT)
lines(x<-c(1:200),(alfa3 * x )/(beta3 + x),col='red')
plot(data = data_grouped , yield ~ olsenP)
lines(x<-c(1:200),(alfa4 * x )/(beta4 + x),col='red')


plot(data = data_fos , yield ~ DGT)
abline(coef(phos.model.DGT_lm))
plot(data = data_fos , yield ~ olsenP)
abline(coef(phos.model.olsenP_lm))


# ggplot
data_plot <- data_fos %>% 
  tidyr::gather("method", "value", DGT, olsenP) %>% 
  dplyr::mutate(method = as.factor(method),
                slope = c(rep(coef(phos.model.DGT_lm)[2], 36), 
                          rep(coef(phos.model.olsenP_lm)[2], 36)),
                intercept = c(rep(coef(phos.model.DGT_lm)[1], 36), 
                              rep(coef(phos.model.olsenP_lm)[1], 36)),
                alfas = c(rep(alfa1, 36), rep(alfa2, 36)),
                betas = c(rep(beta1, 36), rep(beta2, 36)))

levels(data_plot$method) <- c("DGT [µg/L]", "olsenP [mg/100 g]")

ggplot(data_plot, aes(x = value, y = yield)) +
  geom_point() +
  geom_abline(data = data_plot, mapping = aes(slope = slope, intercept = intercept, col = "Linear")) +
  stat_smooth(method = 'nls', formula = 'y ~ alfa * x/(beta + x)',
                method.args = list(start=list(alfa = 90 , beta = 1)), se=F, data = data_plot, mapping = aes(col = "Michaelis-Menten")) +
  facet_wrap(~method, scales = "free") +
  xlab("Bioavailable phosphorous") +
  ylab("Yield [hkg/ha.]") +
  theme(legend.title = element_blank()) +
  theme(legend.position = "bottom")

ggsave("model_comparison.png")

data_plot
  
```

### Parametric bootstrapping - Konfidensintervaller for bestemmelse af parametrene
```{r}
N <- 10000
set.seed(2020)
residuals_DGT <- summary(phos.model.DGT)$residuals
residuals_olsenP <- summary(phos.model.DGT)$residuals

pred_DGT <- predict(phos.model.DGT)
pred_olsenP <- predict(phos.model.olsenP)
BS_coef <- c()
for (i in 1:N){
  print(i)
  BS_DGT <- pred_DGT + sample(residuals_DGT, replace = T)
  BS_olsenP<- pred_olsenP + sample(residuals_olsenP, replace = T)
  
  BS_DGT2 <- pred_DGT + rnorm(36, 0, sqrt(mean(l$residuals^2)))
  BS_olsenP2 <- pred_olsenP + rnorm(36, 0, sqrt(mean(l$residuals^2)))
  
  data_BS <- data.frame(BS_DGT = BS_DGT, BS_DGT2 = BS_DGT2, BS_olsenP = BS_olsenP, BS_olsenP2 = BS_olsenP2, DGT = data_fos$DGT, olsenP = data_fos$olsenP)
  
  
  phos.model.DGT_BS <- nls(BS_DGT ~ alfa * DGT/(beta + DGT), data = data_BS, start = list(alfa = 90 , beta = 1), nls.control(warnOnly = T))
  
  phos.model.olsenP_BS <- nls(BS_olsenP ~ alfa * olsenP/(beta + olsenP), data = data_BS, start = list(alfa = 90 , beta = 1), nls.control(warnOnly = T))
  
    phos.model.DGT_BS2 <- nls(BS_DGT2 ~ alfa * DGT/(beta + DGT), data = data_BS, start = list(alfa = 90 , beta = 1), nls.control(warnOnly = T))
  
  phos.model.olsenP_BS2 <- nls(BS_olsenP2 ~ alfa * olsenP/(beta + olsenP), data = data_BS, start = list(alfa = 90 , beta = 1), nls.control(warnOnly = T))
  
  
  BS_coef <- rbind(BS_coef, c(coef(phos.model.DGT_BS),coef(phos.model.olsenP_BS), coef(phos.model.DGT_BS2), coef(phos.model.olsenP_BS2)))
  
  
}
BS_coef <- as.data.frame(BS_coef)
names(BS_coef) <- c("alfa_DGT","beta_DGT","alfa_olsenP","beta_olsenP","alfa_DGT2","beta_DGT2","alfa_olsenP2","beta_olsenP2")
par(mfrow=c(2,2))
hist(BS_coef$alfa_DGT2)
abline(v = alfa_DGT, col = 3)
hist(BS_coef$beta_DGT2)
abline(v = beta_DGT, col = 3)
hist(BS_coef$alfa_olsenP2)
abline(v = alfa_olsenP, col = 3)
hist(BS_coef$beta_olsenP2)
abline(v = beta_olsenP, col = 3)

CIs <- data.frame(cbind(rbind(quantile(BS_coef$alfa_DGT, c(0.025, 0.975)), 
quantile(BS_coef$beta_DGT, c(0.025, 0.975)),
quantile(BS_coef$alfa_olsenP, c(0.025, 0.975)),
quantile(BS_coef$beta_olsenP, c(0.025, 0.975))), 
rbind(quantile(BS_coef$alfa_DGT2, c(0.025, 0.975)), 
quantile(BS_coef$beta_DGT2, c(0.025, 0.975)),
quantile(BS_coef$alfa_olsenP2, c(0.025, 0.975)),
quantile(BS_coef$beta_olsenP2, c(0.025, 0.975)))),
row.names = c("alfa_DGT","beta_DGT", "alfa_olsenP", "beta_olsenP"))
names(CIs) <- c("Residual 2.5 %", "Residual 97.5 %","Normal 2.5 %", "Normal 97.5 %")
CIs

plot(predict(phos.model.DGT) + rnorm(36, 0, sqrt(mean(l$residuals^2))) ~ data_fos$DGT)
l$residuals
mean(l$residuals^2)
plot(l$residuals)
plot(l$residuals[-36] ~ l$residuals[-1])
cor(l$residuals[-36], l$residuals[-1])

```



#  Predicting Yield
## "Leave 4 out" - cross validation
Bestemmere MSE for begge modeller ved cross validation, hvor i hvert fold udelukkes en location

```{r}
data_CV <- data_fos
level <- levels(data_CV$location)
N <- length(level)

s <- sample(N)
K_fold <- N


accuracy <- c()
random_index <- split(sample(c(1:N),N), c(1:K_fold))
loss <- c()

for (i in c(1:K_fold)){


  train_set <- subset(data_CV, location != level[i])
  test_set <- subset(data_CV, location == level[i])
  model_cv_DGT <- phos.model.DGT_perm <- nls(yield ~ alfa * DGT/(beta + DGT) , data = train_set,
                        start = list(alfa = 90 , beta = 1))
  
  model_cv_olsenP <- phos.model.DGT_perm <- nls(yield ~ alfa * olsenP/(beta + olsenP) , data = train_set,
                        start = list(alfa = 90 , beta = 1))
  
  lm_model_DGT <- lm(data = data_fos, formula = yield ~ DGT)
  lm_model_olsenP <- lm(data = data_fos, formula = yield ~ olsenP)
  
  
  pred_DGT <- predict(model_cv_DGT, test_set)
  pred_olsenP <- predict(model_cv_olsenP, test_set)

  pred_lmDGT <- predict(lm_model_DGT, test_set)
  pred_lmolsenP <- predict(lm_model_olsenP, test_set)

  
  error_DGT <- (test_set$yield - pred_DGT)^2
  error_olsenP <- (test_set$yield - pred_olsenP)^2
  
  error_lmDGT <- (test_set$yield - pred_lmDGT)^2 
  error_lmolsenP <- (test_set$yield - pred_lmolsenP)^2

  loss <- rbind(loss,cbind(error_DGT, error_olsenP, error_lmDGT, error_lmolsenP))
  loss
}
loss <- as.data.frame(loss)
names(loss) <- c("nlDGT", "nlolsenP", "lmDGT", "lmolsenP")
apply(loss,2,mean)

t.test(loss$nlDGT, loss$nlolsenP, paired =T )
Z <- loss$nlDGT - loss$nlolsenP
qqnorm(Z)
qqline(Z)

loss
qqnorm(loss$nlolsenP)
qqline(loss$nlolsenP)
t.test(Z)
214

mean(loss$nlDGT) + sd(loss$nlDGT)/sqrt(36) * qt(0.975, 35)
```


### Bootstrapping for MSE confidence intervals
Difference in performance with Michaelis Menten fitted to DGT vs olsenP
Non parametric bootstrapping. Sampler fra forskel i loss af de to modeller. Udregner mean af disse forskelle og bestemmer konfidens intervaller.
```{r}
a <- 0.05
bootstap_DGT <- replicate(10000,mean(sample(loss$nlDGT, replace = T)))
bootstap_olsenP <- replicate(10000,mean(sample(loss$nlolsenP, replace = T)))
bootstrap_Z <- replicate(10000,mean(sample(Z, replace = T)))
CIs_MSE <- data.frame(rbind(
quantile(bootstap_DGT, c(a/2, 1-a/2)),
quantile(bootstap_olsenP, c(a/2, 1-a/2)),
quantile(bootstrap_Z, c(a/2, 1-a/2))), row.names = c("MSE_DGT","MSE_olsenP","MSE_diff"))
names(CIs_MSE) <- c("2.5%","97.5%")
CIs_MSE
```


### Rank Sum Test 

Difference in performance with Michaelis Menten fitted to DGT vs olsenP
Concatenates loss af DGT og olsenP. Bestemmers størrelseordenen af denne vektor og finder rank sum for DGT.
Derefter laves permutationer af vektor med 1-72 og rank sum af de 36 første bestemmes og sammenlignes med rank sum for DGT

```{r}
Z_RST <- order(c(loss$nlDGT, loss$nlolsenP))
DGT_RS <- sum(Z_RST[1:length(Z_RST)/2])
RST <- c()
for (i in 1:1000){
  RST_sample <- sample(length(Z_RST))
  RST <- c(RST,sum(RST_sample[1:length(Z_RST)/2]))
}
p_val <- 2*mean(DGT_RS>RST)

hist(RST)
abline(v = DGT_RS)
p_val

```

### LEAVE 4 OUT!!!!


```{r}
data_CV <- data_fos
level <- levels(data_CV$location)
N <- length(level)

s <- sample(N)
K_fold <- N


#accuracy <- c()
#random_index <- split(sample(c(1:N),N), c(1:K_fold))
loss <- c()

for (i in sample(c(1:K_fold))){
  print(i)

  train_set <- subset(data_CV, location != level[i])
  test_set <- subset(data_CV, location == level[i])
  model_cv_DGT <- phos.model.DGT_perm <- nls(yield ~ alfa * DGT/(beta + DGT) , data = train_set,
                        start = list(alfa = 90 , beta = 1))
  
  model_cv_olsenP <- phos.model.DGT_perm <- nls(yield ~ alfa * olsenP/(beta + olsenP) , data = train_set,
                        start = list(alfa = 90 , beta = 1))
  
  lm_model_DGT <- lm(data = data_fos, formula = yield ~ DGT)
  lm_model_olsenP <- lm(data = data_fos, formula = yield ~ olsenP)
  
  
  pred_DGT <- predict(model_cv_DGT, test_set)
  pred_olsenP <- predict(model_cv_olsenP, test_set)

  pred_lmDGT <- predict(lm_model_DGT, test_set)
  pred_lmolsenP <- predict(lm_model_olsenP, test_set)

  
  error_DGT <- (test_set$yield - pred_DGT)^2
  error_olsenP <- (test_set$yield - pred_olsenP)^2
  
  error_lmDGT <- (test_set$yield - pred_lmDGT)^2 
  error_lmolsenP <- (test_set$yield - pred_lmolsenP)^2

  loss <- rbind(loss,cbind(error_DGT, error_olsenP, error_lmDGT, error_lmolsenP))
  loss
}
loss <- as.data.frame(loss)
names(loss) <- c("nlDGT", "nlolsenP", "lmDGT", "lmolsenP")
apply(loss,2,mean)

t.test(loss$nlDGT, loss$nlolsenP, paired =T )
```



# Influence of phosphorous


## Permutation - med hensyn til grupper ... 

```{r}
set.seed(1997)
n <- 1000
data_permutation <- data_fos

permutation_list <- split(data_permutation$yield, data_permutation$location)

results <- c()

for (i in 1:n){
  permutation <- sample(9)
  data_permutation$yield = unlist(permutation_list[permutation])
  phos.model.DGT_perm <- nls(yield ~ alfa * DGT/(beta + DGT) , data = data_permutation,
                        start = list(alfa = 90 , beta = 1), nls.control(warnOnly = T, minFactor = 0))
  
  phos.model.olsenP_perm <- nls(yield ~ alfa * olsenP/(beta + olsenP) , data = data_permutation,
                            start = list(alfa = 90 , beta = 1), nls.control(warnOnly = T))
  
  lm_model_DGT_perm <- lm(data = data_permutation, formula = yield ~ DGT)
  lm_model_olsenP_perm <- lm(data = data_permutation, formula = yield ~ olsenP)

  
  results <- rbind(results, c(coef(phos.model.DGT_perm), coef(phos.model.olsenP_perm), coef(lm_model_DGT_perm), coef(lm_model_olsenP_perm)))

}
results <- as.data.frame(results)
names(results) <- c("a-DGT", "b-DGT", "a-olsenP", "b-olsenP", "int. DGT", "slope DGT", "int. olsenP", "slope olsenP")


P_a_perm_DGT <- 2*mean(alfa_DGT < results$`a-DGT`)
P_a_perm_olsenP <- 2*mean(alfa_olsenP < results$`a-olsenP`)
P_b_perm_DGT <- 2*mean(beta_DGT < results$`b-DGT`)
P_b_perm_olsenP <- 2*mean(beta_olsenP < results$`b-olsenP`)

CI_a_DGT_perm <- quantile(results$`a-DGT`, c(a/2, 1-a/2))
CI_a_olsenP_perm <- quantile(results$`a-olsenP`, c(a/2, 1-a/2))
CI_b_DGT_perm <- quantile(results$`b-DGT`, c(a/2, 1-a/2))
CI_b_olsenP_perm <- quantile(results$`b-olsenP`, c(a/2, 1-a/2))

par(mfrow = c(2,2))
hist(results$`a-DGT`)
abline(v = c(CI_a_DGT_perm, alfa_DGT), col = c(2,2,1))

hist(results$`a-olsenP`)
abline(v = c(CI_a_olsenP_perm,alfa_olsenP), col = c(2,2,1))

hist(results$`b-DGT`)
abline(v = c(CI_b_DGT_perm,beta_DGT), col = c(2,2,1))

hist(results$`b-olsenP`)
abline(v = c(CI_b_olsenP_perm,beta_olsenP), col = c(2,2,1))

p_vals_perm <- data.frame(a_DGT = c( CI_a_DGT_perm, alfa_DGT,P_a_perm_DGT), b_DGT = c( CI_b_DGT_perm, beta_DGT,P_b_perm_DGT), a_olsenP = c( CI_a_olsenP_perm,alfa_olsenP,P_a_perm_olsenP), b_olsenP = c(CI_b_olsenP_perm, beta_olsenP,P_b_perm_olsenP), row.names =c("2.5 %", "97.5 % ", "observed value", "p-value"))
p_vals_perm
```




```{r}
data_fos
model <- lm(data = data_fos, formula = yield ~ location)
summary(model)
anova(model)
par(mfrow = c(1,2))
boxplot(data_fos$yield ~ data_fos$location)
plot(data_fos$yield ~ data_fos$location, ylim = c(0,100))
points(data_fos$yield ~ data_fos$location, col = 2)
coef(model)

```







